// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `routing.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct LightningAddress {
    // message fields
    pub pubkey: ::std::string::String,
    pub host: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightningAddress {
    fn default() -> &'a LightningAddress {
        <LightningAddress as ::protobuf::Message>::default_instance()
    }
}

impl LightningAddress {
    pub fn new() -> LightningAddress {
        ::std::default::Default::default()
    }

    // string pubkey = 1;


    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightningAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pubkey);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pubkey.is_empty() {
            os.write_string(1, &self.pubkey)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningAddress {
        LightningAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pubkey",
                    |m: &LightningAddress| { &m.pubkey },
                    |m: &mut LightningAddress| { &mut m.pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &LightningAddress| { &m.host },
                    |m: &mut LightningAddress| { &mut m.host },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LightningAddress>(
                    "LightningAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LightningAddress {
        static mut instance: ::protobuf::lazy::Lazy<LightningAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LightningAddress,
        };
        unsafe {
            instance.get(LightningAddress::new)
        }
    }
}

impl ::protobuf::Clear for LightningAddress {
    fn clear(&mut self) {
        self.pubkey.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    pub pub_key: ::std::string::String,
    pub address: ::std::string::String,
    pub bytes_sent: u64,
    pub bytes_recv: u64,
    pub sat_sent: ::protobuf::SingularPtrField<super::common::Satoshi>,
    pub sat_recv: ::protobuf::SingularPtrField<super::common::Satoshi>,
    pub inbound: bool,
    pub ping_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint64 bytes_sent = 4;


    pub fn get_bytes_sent(&self) -> u64 {
        self.bytes_sent
    }
    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: u64) {
        self.bytes_sent = v;
    }

    // uint64 bytes_recv = 5;


    pub fn get_bytes_recv(&self) -> u64 {
        self.bytes_recv
    }
    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: u64) {
        self.bytes_recv = v;
    }

    // .Satoshi sat_sent = 6;


    pub fn get_sat_sent(&self) -> &super::common::Satoshi {
        self.sat_sent.as_ref().unwrap_or_else(|| super::common::Satoshi::default_instance())
    }
    pub fn clear_sat_sent(&mut self) {
        self.sat_sent.clear();
    }

    pub fn has_sat_sent(&self) -> bool {
        self.sat_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sat_sent(&mut self, v: super::common::Satoshi) {
        self.sat_sent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sat_sent(&mut self) -> &mut super::common::Satoshi {
        if self.sat_sent.is_none() {
            self.sat_sent.set_default();
        }
        self.sat_sent.as_mut().unwrap()
    }

    // Take field
    pub fn take_sat_sent(&mut self) -> super::common::Satoshi {
        self.sat_sent.take().unwrap_or_else(|| super::common::Satoshi::new())
    }

    // .Satoshi sat_recv = 7;


    pub fn get_sat_recv(&self) -> &super::common::Satoshi {
        self.sat_recv.as_ref().unwrap_or_else(|| super::common::Satoshi::default_instance())
    }
    pub fn clear_sat_recv(&mut self) {
        self.sat_recv.clear();
    }

    pub fn has_sat_recv(&self) -> bool {
        self.sat_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sat_recv(&mut self, v: super::common::Satoshi) {
        self.sat_recv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sat_recv(&mut self) -> &mut super::common::Satoshi {
        if self.sat_recv.is_none() {
            self.sat_recv.set_default();
        }
        self.sat_recv.as_mut().unwrap()
    }

    // Take field
    pub fn take_sat_recv(&mut self) -> super::common::Satoshi {
        self.sat_recv.take().unwrap_or_else(|| super::common::Satoshi::new())
    }

    // bool inbound = 8;


    pub fn get_inbound(&self) -> bool {
        self.inbound
    }
    pub fn clear_inbound(&mut self) {
        self.inbound = false;
    }

    // Param is passed by value, moved
    pub fn set_inbound(&mut self, v: bool) {
        self.inbound = v;
    }

    // int64 ping_time = 9;


    pub fn get_ping_time(&self) -> i64 {
        self.ping_time
    }
    pub fn clear_ping_time(&mut self) {
        self.ping_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: i64) {
        self.ping_time = v;
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        for v in &self.sat_sent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sat_recv {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_sent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_recv = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sat_sent)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sat_recv)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inbound = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ping_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.bytes_sent != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bytes_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_recv != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bytes_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sat_sent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sat_recv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.inbound != false {
            my_size += 2;
        }
        if self.ping_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.ping_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.bytes_sent != 0 {
            os.write_uint64(4, self.bytes_sent)?;
        }
        if self.bytes_recv != 0 {
            os.write_uint64(5, self.bytes_recv)?;
        }
        if let Some(ref v) = self.sat_sent.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sat_recv.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.inbound != false {
            os.write_bool(8, self.inbound)?;
        }
        if self.ping_time != 0 {
            os.write_int64(9, self.ping_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &Peer| { &m.pub_key },
                    |m: &mut Peer| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &Peer| { &m.address },
                    |m: &mut Peer| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_sent",
                    |m: &Peer| { &m.bytes_sent },
                    |m: &mut Peer| { &mut m.bytes_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_recv",
                    |m: &Peer| { &m.bytes_recv },
                    |m: &mut Peer| { &mut m.bytes_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Satoshi>>(
                    "sat_sent",
                    |m: &Peer| { &m.sat_sent },
                    |m: &mut Peer| { &mut m.sat_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Satoshi>>(
                    "sat_recv",
                    |m: &Peer| { &m.sat_recv },
                    |m: &mut Peer| { &mut m.sat_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inbound",
                    |m: &Peer| { &m.inbound },
                    |m: &mut Peer| { &mut m.inbound },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ping_time",
                    |m: &Peer| { &m.ping_time },
                    |m: &mut Peer| { &mut m.ping_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Peer>(
                    "Peer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Peer {
        static mut instance: ::protobuf::lazy::Lazy<Peer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Peer,
        };
        unsafe {
            instance.get(Peer::new)
        }
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.address.clear();
        self.bytes_sent = 0;
        self.bytes_recv = 0;
        self.sat_sent.clear();
        self.sat_recv.clear();
        self.inbound = false;
        self.ping_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageRequest {
    // message fields
    pub message: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageRequest {
    fn default() -> &'a SignMessageRequest {
        <SignMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageRequest {
    pub fn new() -> SignMessageRequest {
        ::std::default::Default::default()
    }

    // bytes message = 1;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_bytes(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageRequest {
        SignMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message",
                    |m: &SignMessageRequest| { &m.message },
                    |m: &mut SignMessageRequest| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageRequest>(
                    "SignMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageRequest,
        };
        unsafe {
            instance.get(SignMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageRequest {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageResponse {
    // message fields
    pub signature: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageResponse {
    fn default() -> &'a SignMessageResponse {
        <SignMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageResponse {
    pub fn new() -> SignMessageResponse {
        ::std::default::Default::default()
    }

    // string signature = 1;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_string(1, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageResponse {
        SignMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &SignMessageResponse| { &m.signature },
                    |m: &mut SignMessageResponse| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageResponse>(
                    "SignMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageResponse,
        };
        unsafe {
            instance.get(SignMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageResponse {
    fn clear(&mut self) {
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectPeerRequest {
    // message fields
    pub address: ::protobuf::SingularPtrField<LightningAddress>,
    pub perm: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectPeerRequest {
    fn default() -> &'a ConnectPeerRequest {
        <ConnectPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectPeerRequest {
    pub fn new() -> ConnectPeerRequest {
        ::std::default::Default::default()
    }

    // .LightningAddress address = 1;


    pub fn get_address(&self) -> &LightningAddress {
        self.address.as_ref().unwrap_or_else(|| LightningAddress::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: LightningAddress) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut LightningAddress {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> LightningAddress {
        self.address.take().unwrap_or_else(|| LightningAddress::new())
    }

    // bool perm = 2;


    pub fn get_perm(&self) -> bool {
        self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm = false;
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: bool) {
        self.perm = v;
    }
}

impl ::protobuf::Message for ConnectPeerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perm = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.perm != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.perm != false {
            os.write_bool(2, self.perm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerRequest {
        ConnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningAddress>>(
                    "address",
                    |m: &ConnectPeerRequest| { &m.address },
                    |m: &mut ConnectPeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "perm",
                    |m: &ConnectPeerRequest| { &m.perm },
                    |m: &mut ConnectPeerRequest| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectPeerRequest>(
                    "ConnectPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnectPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectPeerRequest,
        };
        unsafe {
            instance.get(ConnectPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnectPeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.perm = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerList {
    // message fields
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerList {
    fn default() -> &'a PeerList {
        <PeerList as ::protobuf::Message>::default_instance()
    }
}

impl PeerList {
    pub fn new() -> PeerList {
        ::std::default::Default::default()
    }

    // repeated .Peer peers = 1;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PeerList {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerList {
        PeerList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peers",
                    |m: &PeerList| { &m.peers },
                    |m: &mut PeerList| { &mut m.peers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerList>(
                    "PeerList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PeerList {
        static mut instance: ::protobuf::lazy::Lazy<PeerList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerList,
        };
        unsafe {
            instance.get(PeerList::new)
        }
    }
}

impl ::protobuf::Clear for PeerList {
    fn clear(&mut self) {
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Info {
    // message fields
    pub identity_pubkey: ::std::string::String,
    pub alias: ::std::string::String,
    pub num_pending_channels: u32,
    pub num_active_channels: u32,
    pub num_peers: u32,
    pub block_height: u32,
    pub block_hash: ::std::string::String,
    pub synced_to_chain: bool,
    pub testnet: bool,
    pub chains: ::protobuf::RepeatedField<::std::string::String>,
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    pub best_header_timestamp: i64,
    pub version: ::std::string::String,
    pub num_inactive_channels: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Info {
    fn default() -> &'a Info {
        <Info as ::protobuf::Message>::default_instance()
    }
}

impl Info {
    pub fn new() -> Info {
        ::std::default::Default::default()
    }

    // string identity_pubkey = 1;


    pub fn get_identity_pubkey(&self) -> &str {
        &self.identity_pubkey
    }
    pub fn clear_identity_pubkey(&mut self) {
        self.identity_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_pubkey(&mut self, v: ::std::string::String) {
        self.identity_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.identity_pubkey
    }

    // Take field
    pub fn take_identity_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_pubkey, ::std::string::String::new())
    }

    // string alias = 2;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // uint32 num_pending_channels = 3;


    pub fn get_num_pending_channels(&self) -> u32 {
        self.num_pending_channels
    }
    pub fn clear_num_pending_channels(&mut self) {
        self.num_pending_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pending_channels(&mut self, v: u32) {
        self.num_pending_channels = v;
    }

    // uint32 num_active_channels = 4;


    pub fn get_num_active_channels(&self) -> u32 {
        self.num_active_channels
    }
    pub fn clear_num_active_channels(&mut self) {
        self.num_active_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_active_channels(&mut self, v: u32) {
        self.num_active_channels = v;
    }

    // uint32 num_peers = 5;


    pub fn get_num_peers(&self) -> u32 {
        self.num_peers
    }
    pub fn clear_num_peers(&mut self) {
        self.num_peers = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_peers(&mut self, v: u32) {
        self.num_peers = v;
    }

    // uint32 block_height = 6;


    pub fn get_block_height(&self) -> u32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u32) {
        self.block_height = v;
    }

    // string block_hash = 8;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // bool synced_to_chain = 9;


    pub fn get_synced_to_chain(&self) -> bool {
        self.synced_to_chain
    }
    pub fn clear_synced_to_chain(&mut self) {
        self.synced_to_chain = false;
    }

    // Param is passed by value, moved
    pub fn set_synced_to_chain(&mut self, v: bool) {
        self.synced_to_chain = v;
    }

    // bool testnet = 10;


    pub fn get_testnet(&self) -> bool {
        self.testnet
    }
    pub fn clear_testnet(&mut self) {
        self.testnet = false;
    }

    // Param is passed by value, moved
    pub fn set_testnet(&mut self, v: bool) {
        self.testnet = v;
    }

    // repeated string chains = 11;


    pub fn get_chains(&self) -> &[::std::string::String] {
        &self.chains
    }
    pub fn clear_chains(&mut self) {
        self.chains.clear();
    }

    // Param is passed by value, moved
    pub fn set_chains(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.chains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chains(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.chains
    }

    // Take field
    pub fn take_chains(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.chains, ::protobuf::RepeatedField::new())
    }

    // repeated string uris = 12;


    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    // int64 best_header_timestamp = 13;


    pub fn get_best_header_timestamp(&self) -> i64 {
        self.best_header_timestamp
    }
    pub fn clear_best_header_timestamp(&mut self) {
        self.best_header_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_best_header_timestamp(&mut self, v: i64) {
        self.best_header_timestamp = v;
    }

    // string version = 14;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // uint32 num_inactive_channels = 15;


    pub fn get_num_inactive_channels(&self) -> u32 {
        self.num_inactive_channels
    }
    pub fn clear_num_inactive_channels(&mut self) {
        self.num_inactive_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_inactive_channels(&mut self, v: u32) {
        self.num_inactive_channels = v;
    }
}

impl ::protobuf::Message for Info {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_pending_channels = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_active_channels = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_peers = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_height = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.synced_to_chain = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.testnet = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.chains)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.best_header_timestamp = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_inactive_channels = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_pubkey);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.alias);
        }
        if self.num_pending_channels != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_pending_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_active_channels != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_active_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_peers != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_peers, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(6, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.block_hash);
        }
        if self.synced_to_chain != false {
            my_size += 2;
        }
        if self.testnet != false {
            my_size += 2;
        }
        for value in &self.chains {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        if self.best_header_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(13, self.best_header_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.version);
        }
        if self.num_inactive_channels != 0 {
            my_size += ::protobuf::rt::value_size(15, self.num_inactive_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_pubkey.is_empty() {
            os.write_string(1, &self.identity_pubkey)?;
        }
        if !self.alias.is_empty() {
            os.write_string(2, &self.alias)?;
        }
        if self.num_pending_channels != 0 {
            os.write_uint32(3, self.num_pending_channels)?;
        }
        if self.num_active_channels != 0 {
            os.write_uint32(4, self.num_active_channels)?;
        }
        if self.num_peers != 0 {
            os.write_uint32(5, self.num_peers)?;
        }
        if self.block_height != 0 {
            os.write_uint32(6, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(8, &self.block_hash)?;
        }
        if self.synced_to_chain != false {
            os.write_bool(9, self.synced_to_chain)?;
        }
        if self.testnet != false {
            os.write_bool(10, self.testnet)?;
        }
        for v in &self.chains {
            os.write_string(11, &v)?;
        };
        for v in &self.uris {
            os.write_string(12, &v)?;
        };
        if self.best_header_timestamp != 0 {
            os.write_int64(13, self.best_header_timestamp)?;
        }
        if !self.version.is_empty() {
            os.write_string(14, &self.version)?;
        }
        if self.num_inactive_channels != 0 {
            os.write_uint32(15, self.num_inactive_channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Info {
        Info::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity_pubkey",
                    |m: &Info| { &m.identity_pubkey },
                    |m: &mut Info| { &mut m.identity_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &Info| { &m.alias },
                    |m: &mut Info| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_pending_channels",
                    |m: &Info| { &m.num_pending_channels },
                    |m: &mut Info| { &mut m.num_pending_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_active_channels",
                    |m: &Info| { &m.num_active_channels },
                    |m: &mut Info| { &mut m.num_active_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_peers",
                    |m: &Info| { &m.num_peers },
                    |m: &mut Info| { &mut m.num_peers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "block_height",
                    |m: &Info| { &m.block_height },
                    |m: &mut Info| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &Info| { &m.block_hash },
                    |m: &mut Info| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "synced_to_chain",
                    |m: &Info| { &m.synced_to_chain },
                    |m: &mut Info| { &mut m.synced_to_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "testnet",
                    |m: &Info| { &m.testnet },
                    |m: &mut Info| { &mut m.testnet },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chains",
                    |m: &Info| { &m.chains },
                    |m: &mut Info| { &mut m.chains },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uris",
                    |m: &Info| { &m.uris },
                    |m: &mut Info| { &mut m.uris },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "best_header_timestamp",
                    |m: &Info| { &m.best_header_timestamp },
                    |m: &mut Info| { &mut m.best_header_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &Info| { &m.version },
                    |m: &mut Info| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_inactive_channels",
                    |m: &Info| { &m.num_inactive_channels },
                    |m: &mut Info| { &mut m.num_inactive_channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Info>(
                    "Info",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Info {
        static mut instance: ::protobuf::lazy::Lazy<Info> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Info,
        };
        unsafe {
            instance.get(Info::new)
        }
    }
}

impl ::protobuf::Clear for Info {
    fn clear(&mut self) {
        self.identity_pubkey.clear();
        self.alias.clear();
        self.num_pending_channels = 0;
        self.num_active_channels = 0;
        self.num_peers = 0;
        self.block_height = 0;
        self.block_hash.clear();
        self.synced_to_chain = false;
        self.testnet = false;
        self.chains.clear();
        self.uris.clear();
        self.best_header_timestamp = 0;
        self.version.clear();
        self.num_inactive_channels = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Info {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelGraphRequest {
    // message fields
    pub include_unannounced: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelGraphRequest {
    fn default() -> &'a ChannelGraphRequest {
        <ChannelGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelGraphRequest {
    pub fn new() -> ChannelGraphRequest {
        ::std::default::Default::default()
    }

    // bool include_unannounced = 1;


    pub fn get_include_unannounced(&self) -> bool {
        self.include_unannounced
    }
    pub fn clear_include_unannounced(&mut self) {
        self.include_unannounced = false;
    }

    // Param is passed by value, moved
    pub fn set_include_unannounced(&mut self, v: bool) {
        self.include_unannounced = v;
    }
}

impl ::protobuf::Message for ChannelGraphRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_unannounced = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_unannounced != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.include_unannounced != false {
            os.write_bool(1, self.include_unannounced)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraphRequest {
        ChannelGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_unannounced",
                    |m: &ChannelGraphRequest| { &m.include_unannounced },
                    |m: &mut ChannelGraphRequest| { &mut m.include_unannounced },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelGraphRequest>(
                    "ChannelGraphRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelGraphRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChannelGraphRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelGraphRequest,
        };
        unsafe {
            instance.get(ChannelGraphRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChannelGraphRequest {
    fn clear(&mut self) {
        self.include_unannounced = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelGraph {
    // message fields
    pub nodes: ::protobuf::RepeatedField<LightningNode>,
    pub edges: ::protobuf::RepeatedField<ChannelEdge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelGraph {
    fn default() -> &'a ChannelGraph {
        <ChannelGraph as ::protobuf::Message>::default_instance()
    }
}

impl ChannelGraph {
    pub fn new() -> ChannelGraph {
        ::std::default::Default::default()
    }

    // repeated .LightningNode nodes = 1;


    pub fn get_nodes(&self) -> &[LightningNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<LightningNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<LightningNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<LightningNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .ChannelEdge edges = 2;


    pub fn get_edges(&self) -> &[ChannelEdge] {
        &self.edges
    }
    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::protobuf::RepeatedField<ChannelEdge>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdge> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::protobuf::RepeatedField<ChannelEdge> {
        ::std::mem::replace(&mut self.edges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelGraph {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraph {
        ChannelGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                    "nodes",
                    |m: &ChannelGraph| { &m.nodes },
                    |m: &mut ChannelGraph| { &mut m.nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdge>>(
                    "edges",
                    |m: &ChannelGraph| { &m.edges },
                    |m: &mut ChannelGraph| { &mut m.edges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelGraph>(
                    "ChannelGraph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelGraph {
        static mut instance: ::protobuf::lazy::Lazy<ChannelGraph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelGraph,
        };
        unsafe {
            instance.get(ChannelGraph::new)
        }
    }
}

impl ::protobuf::Clear for ChannelGraph {
    fn clear(&mut self) {
        self.nodes.clear();
        self.edges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightningNode {
    // message fields
    pub last_update: u32,
    pub pub_key: ::std::string::String,
    pub alias: ::std::string::String,
    pub addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub color: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightningNode {
    fn default() -> &'a LightningNode {
        <LightningNode as ::protobuf::Message>::default_instance()
    }
}

impl LightningNode {
    pub fn new() -> LightningNode {
        ::std::default::Default::default()
    }

    // uint32 last_update = 1;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    // string pub_key = 2;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string alias = 3;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // repeated .NodeAddress addresses = 4;


    pub fn get_addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // string color = 5;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightningNode {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(1, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pub_key);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.alias);
        }
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.last_update != 0 {
            os.write_uint32(1, self.last_update)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(2, &self.pub_key)?;
        }
        if !self.alias.is_empty() {
            os.write_string(3, &self.alias)?;
        }
        for v in &self.addresses {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningNode {
        LightningNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &LightningNode| { &m.last_update },
                    |m: &mut LightningNode| { &mut m.last_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &LightningNode| { &m.pub_key },
                    |m: &mut LightningNode| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &LightningNode| { &m.alias },
                    |m: &mut LightningNode| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                    "addresses",
                    |m: &LightningNode| { &m.addresses },
                    |m: &mut LightningNode| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "color",
                    |m: &LightningNode| { &m.color },
                    |m: &mut LightningNode| { &mut m.color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LightningNode>(
                    "LightningNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LightningNode {
        static mut instance: ::protobuf::lazy::Lazy<LightningNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LightningNode,
        };
        unsafe {
            instance.get(LightningNode::new)
        }
    }
}

impl ::protobuf::Clear for LightningNode {
    fn clear(&mut self) {
        self.last_update = 0;
        self.pub_key.clear();
        self.alias.clear();
        self.addresses.clear();
        self.color.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddress {
    // message fields
    pub network: ::std::string::String,
    pub addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // string network = 1;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    // string addr = 2;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "network",
                    |m: &NodeAddress| { &m.network },
                    |m: &mut NodeAddress| { &mut m.network },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addr",
                    |m: &NodeAddress| { &m.addr },
                    |m: &mut NodeAddress| { &mut m.addr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddress>(
                    "NodeAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAddress {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddress,
        };
        unsafe {
            instance.get(NodeAddress::new)
        }
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.network.clear();
        self.addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEdge {
    // message fields
    pub channel_id: u64,
    pub chan_point: ::std::string::String,
    pub last_update: u32,
    pub node1_pub: ::std::string::String,
    pub node2_pub: ::std::string::String,
    pub capacity: i64,
    pub node1_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub node2_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEdge {
    fn default() -> &'a ChannelEdge {
        <ChannelEdge as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEdge {
    pub fn new() -> ChannelEdge {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // string chan_point = 2;


    pub fn get_chan_point(&self) -> &str {
        &self.chan_point
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ::std::string::String) {
        self.chan_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ::std::string::String {
        &mut self.chan_point
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_point, ::std::string::String::new())
    }

    // uint32 last_update = 3;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    // string node1_pub = 4;


    pub fn get_node1_pub(&self) -> &str {
        &self.node1_pub
    }
    pub fn clear_node1_pub(&mut self) {
        self.node1_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node1_pub(&mut self, v: ::std::string::String) {
        self.node1_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node1_pub
    }

    // Take field
    pub fn take_node1_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node1_pub, ::std::string::String::new())
    }

    // string node2_pub = 5;


    pub fn get_node2_pub(&self) -> &str {
        &self.node2_pub
    }
    pub fn clear_node2_pub(&mut self) {
        self.node2_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node2_pub(&mut self, v: ::std::string::String) {
        self.node2_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node2_pub
    }

    // Take field
    pub fn take_node2_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node2_pub, ::std::string::String::new())
    }

    // int64 capacity = 6;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // .RoutingPolicy node1_policy = 7;


    pub fn get_node1_policy(&self) -> &RoutingPolicy {
        self.node1_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }
    pub fn clear_node1_policy(&mut self) {
        self.node1_policy.clear();
    }

    pub fn has_node1_policy(&self) -> bool {
        self.node1_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node1_policy(&mut self, v: RoutingPolicy) {
        self.node1_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_policy(&mut self) -> &mut RoutingPolicy {
        if self.node1_policy.is_none() {
            self.node1_policy.set_default();
        }
        self.node1_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node1_policy(&mut self) -> RoutingPolicy {
        self.node1_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    // .RoutingPolicy node2_policy = 8;


    pub fn get_node2_policy(&self) -> &RoutingPolicy {
        self.node2_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }
    pub fn clear_node2_policy(&mut self) {
        self.node2_policy.clear();
    }

    pub fn has_node2_policy(&self) -> bool {
        self.node2_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node2_policy(&mut self, v: RoutingPolicy) {
        self.node2_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_policy(&mut self) -> &mut RoutingPolicy {
        if self.node2_policy.is_none() {
            self.node2_policy.set_default();
        }
        self.node2_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node2_policy(&mut self) -> RoutingPolicy {
        self.node2_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }
}

impl ::protobuf::Message for ChannelEdge {
    fn is_initialized(&self) -> bool {
        for v in &self.node1_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node2_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node1_pub)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node2_pub)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node1_policy)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node2_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chan_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chan_point);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node1_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node1_pub);
        }
        if !self.node2_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node2_pub);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if !self.chan_point.is_empty() {
            os.write_string(2, &self.chan_point)?;
        }
        if self.last_update != 0 {
            os.write_uint32(3, self.last_update)?;
        }
        if !self.node1_pub.is_empty() {
            os.write_string(4, &self.node1_pub)?;
        }
        if !self.node2_pub.is_empty() {
            os.write_string(5, &self.node2_pub)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdge {
        ChannelEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "channel_id",
                    |m: &ChannelEdge| { &m.channel_id },
                    |m: &mut ChannelEdge| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chan_point",
                    |m: &ChannelEdge| { &m.chan_point },
                    |m: &mut ChannelEdge| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &ChannelEdge| { &m.last_update },
                    |m: &mut ChannelEdge| { &mut m.last_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node1_pub",
                    |m: &ChannelEdge| { &m.node1_pub },
                    |m: &mut ChannelEdge| { &mut m.node1_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node2_pub",
                    |m: &ChannelEdge| { &m.node2_pub },
                    |m: &mut ChannelEdge| { &mut m.node2_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelEdge| { &m.capacity },
                    |m: &mut ChannelEdge| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "node1_policy",
                    |m: &ChannelEdge| { &m.node1_policy },
                    |m: &mut ChannelEdge| { &mut m.node1_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "node2_policy",
                    |m: &ChannelEdge| { &m.node2_policy },
                    |m: &mut ChannelEdge| { &mut m.node2_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEdge>(
                    "ChannelEdge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEdge {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEdge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEdge,
        };
        unsafe {
            instance.get(ChannelEdge::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEdge {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.chan_point.clear();
        self.last_update = 0;
        self.node1_pub.clear();
        self.node2_pub.clear();
        self.capacity = 0;
        self.node1_policy.clear();
        self.node2_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingPolicy {
    // message fields
    pub time_lock_delta: u32,
    pub min_htlc: i64,
    pub fee_base_msat: i64,
    pub fee_rate_milli: ::protobuf::SingularPtrField<super::common::MilliSatoshi>,
    pub disabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingPolicy {
    fn default() -> &'a RoutingPolicy {
        <RoutingPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RoutingPolicy {
    pub fn new() -> RoutingPolicy {
        ::std::default::Default::default()
    }

    // uint32 time_lock_delta = 1;


    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    // int64 min_htlc = 2;


    pub fn get_min_htlc(&self) -> i64 {
        self.min_htlc
    }
    pub fn clear_min_htlc(&mut self) {
        self.min_htlc = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc(&mut self, v: i64) {
        self.min_htlc = v;
    }

    // int64 fee_base_msat = 3;


    pub fn get_fee_base_msat(&self) -> i64 {
        self.fee_base_msat
    }
    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: i64) {
        self.fee_base_msat = v;
    }

    // .MilliSatoshi fee_rate_milli = 4;


    pub fn get_fee_rate_milli(&self) -> &super::common::MilliSatoshi {
        self.fee_rate_milli.as_ref().unwrap_or_else(|| super::common::MilliSatoshi::default_instance())
    }
    pub fn clear_fee_rate_milli(&mut self) {
        self.fee_rate_milli.clear();
    }

    pub fn has_fee_rate_milli(&self) -> bool {
        self.fee_rate_milli.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_rate_milli(&mut self, v: super::common::MilliSatoshi) {
        self.fee_rate_milli = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_rate_milli(&mut self) -> &mut super::common::MilliSatoshi {
        if self.fee_rate_milli.is_none() {
            self.fee_rate_milli.set_default();
        }
        self.fee_rate_milli.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_rate_milli(&mut self) -> super::common::MilliSatoshi {
        self.fee_rate_milli.take().unwrap_or_else(|| super::common::MilliSatoshi::new())
    }

    // bool disabled = 5;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for RoutingPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_rate_milli {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_rate_milli)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_htlc, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_rate_milli.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time_lock_delta != 0 {
            os.write_uint32(1, self.time_lock_delta)?;
        }
        if self.min_htlc != 0 {
            os.write_int64(2, self.min_htlc)?;
        }
        if self.fee_base_msat != 0 {
            os.write_int64(3, self.fee_base_msat)?;
        }
        if let Some(ref v) = self.fee_rate_milli.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.disabled != false {
            os.write_bool(5, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingPolicy {
        RoutingPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_lock_delta",
                    |m: &RoutingPolicy| { &m.time_lock_delta },
                    |m: &mut RoutingPolicy| { &mut m.time_lock_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_htlc",
                    |m: &RoutingPolicy| { &m.min_htlc },
                    |m: &mut RoutingPolicy| { &mut m.min_htlc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_base_msat",
                    |m: &RoutingPolicy| { &m.fee_base_msat },
                    |m: &mut RoutingPolicy| { &mut m.fee_base_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::MilliSatoshi>>(
                    "fee_rate_milli",
                    |m: &RoutingPolicy| { &m.fee_rate_milli },
                    |m: &mut RoutingPolicy| { &mut m.fee_rate_milli },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disabled",
                    |m: &RoutingPolicy| { &m.disabled },
                    |m: &mut RoutingPolicy| { &mut m.disabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoutingPolicy>(
                    "RoutingPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoutingPolicy {
        static mut instance: ::protobuf::lazy::Lazy<RoutingPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoutingPolicy,
        };
        unsafe {
            instance.get(RoutingPolicy::new)
        }
    }
}

impl ::protobuf::Clear for RoutingPolicy {
    fn clear(&mut self) {
        self.time_lock_delta = 0;
        self.min_htlc = 0;
        self.fee_base_msat = 0;
        self.fee_rate_milli.clear();
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRoutesRequest {
    // message fields
    pub pub_key: ::std::string::String,
    pub amt: i64,
    pub num_routes: i32,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<super::common::FeeLimit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRoutesRequest {
    fn default() -> &'a QueryRoutesRequest {
        <QueryRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRoutesRequest {
    pub fn new() -> QueryRoutesRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // int64 amt = 2;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int32 num_routes = 3;


    pub fn get_num_routes(&self) -> i32 {
        self.num_routes
    }
    pub fn clear_num_routes(&mut self) {
        self.num_routes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_routes(&mut self, v: i32) {
        self.num_routes = v;
    }

    // int32 final_cltv_delta = 4;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // .FeeLimit fee_limit = 5;


    pub fn get_fee_limit(&self) -> &super::common::FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| super::common::FeeLimit::default_instance())
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: super::common::FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut super::common::FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> super::common::FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| super::common::FeeLimit::new())
    }
}

impl ::protobuf::Message for QueryRoutesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_routes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_routes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_routes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(4, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.amt != 0 {
            os.write_int64(2, self.amt)?;
        }
        if self.num_routes != 0 {
            os.write_int32(3, self.num_routes)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(4, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesRequest {
        QueryRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &QueryRoutesRequest| { &m.pub_key },
                    |m: &mut QueryRoutesRequest| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt",
                    |m: &QueryRoutesRequest| { &m.amt },
                    |m: &mut QueryRoutesRequest| { &mut m.amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_routes",
                    |m: &QueryRoutesRequest| { &m.num_routes },
                    |m: &mut QueryRoutesRequest| { &mut m.num_routes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_cltv_delta",
                    |m: &QueryRoutesRequest| { &m.final_cltv_delta },
                    |m: &mut QueryRoutesRequest| { &mut m.final_cltv_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::FeeLimit>>(
                    "fee_limit",
                    |m: &QueryRoutesRequest| { &m.fee_limit },
                    |m: &mut QueryRoutesRequest| { &mut m.fee_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRoutesRequest>(
                    "QueryRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<QueryRoutesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRoutesRequest,
        };
        unsafe {
            instance.get(QueryRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for QueryRoutesRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.amt = 0;
        self.num_routes = 0;
        self.final_cltv_delta = 0;
        self.fee_limit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteList {
    // message fields
    pub routes: ::protobuf::RepeatedField<super::common::Route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteList {
    fn default() -> &'a RouteList {
        <RouteList as ::protobuf::Message>::default_instance()
    }
}

impl RouteList {
    pub fn new() -> RouteList {
        ::std::default::Default::default()
    }

    // repeated .Route routes = 1;


    pub fn get_routes(&self) -> &[super::common::Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<super::common::Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<super::common::Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RouteList {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteList {
        RouteList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Route>>(
                    "routes",
                    |m: &RouteList| { &m.routes },
                    |m: &mut RouteList| { &mut m.routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteList>(
                    "RouteList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteList {
        static mut instance: ::protobuf::lazy::Lazy<RouteList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteList,
        };
        unsafe {
            instance.get(RouteList::new)
        }
    }
}

impl ::protobuf::Clear for RouteList {
    fn clear(&mut self) {
        self.routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rrouting.proto\x1a\x0ccommon.proto\">\n\x10LightningAddress\x12\x16\n\
    \x06pubkey\x18\x01\x20\x01(\tR\x06pubkey\x12\x12\n\x04host\x18\x02\x20\
    \x01(\tR\x04host\"\xfe\x01\n\x04Peer\x12\x18\n\x07pub_key\x18\x01\x20\
    \x01(\tR\x07pub_key\x12\x18\n\x07address\x18\x03\x20\x01(\tR\x07address\
    \x12\x1e\n\nbytes_sent\x18\x04\x20\x01(\x04R\nbytes_sent\x12\x1e\n\nbyte\
    s_recv\x18\x05\x20\x01(\x04R\nbytes_recv\x12$\n\x08sat_sent\x18\x06\x20\
    \x01(\x0b2\x08.SatoshiR\x08sat_sent\x12$\n\x08sat_recv\x18\x07\x20\x01(\
    \x0b2\x08.SatoshiR\x08sat_recv\x12\x18\n\x07inbound\x18\x08\x20\x01(\x08\
    R\x07inbound\x12\x1c\n\tping_time\x18\t\x20\x01(\x03R\tping_time\"*\n\
    \x12SignMessageRequest\x12\x14\n\x07message\x18\x01\x20\x01(\x0cR\x03msg\
    \"3\n\x13SignMessageResponse\x12\x1c\n\tsignature\x18\x01\x20\x01(\tR\ts\
    ignature\"U\n\x12ConnectPeerRequest\x12+\n\x07address\x18\x01\x20\x01(\
    \x0b2\x11.LightningAddressR\x07address\x12\x12\n\x04perm\x18\x02\x20\x01\
    (\x08R\x04perm\"'\n\x08PeerList\x12\x1b\n\x05peers\x18\x01\x20\x03(\x0b2\
    \x05.PeerR\x05peers\"\x84\x04\n\x04Info\x12(\n\x0fidentity_pubkey\x18\
    \x01\x20\x01(\tR\x0fidentity_pubkey\x12\x14\n\x05alias\x18\x02\x20\x01(\
    \tR\x05alias\x122\n\x14num_pending_channels\x18\x03\x20\x01(\rR\x14num_p\
    ending_channels\x120\n\x13num_active_channels\x18\x04\x20\x01(\rR\x13num\
    _active_channels\x12\x1c\n\tnum_peers\x18\x05\x20\x01(\rR\tnum_peers\x12\
    \"\n\x0cblock_height\x18\x06\x20\x01(\rR\x0cblock_height\x12\x1e\n\nbloc\
    k_hash\x18\x08\x20\x01(\tR\nblock_hash\x12(\n\x0fsynced_to_chain\x18\t\
    \x20\x01(\x08R\x0fsynced_to_chain\x12\x18\n\x07testnet\x18\n\x20\x01(\
    \x08R\x07testnet\x12\x16\n\x06chains\x18\x0b\x20\x03(\tR\x06chains\x12\
    \x12\n\x04uris\x18\x0c\x20\x03(\tR\x04uris\x124\n\x15best_header_timesta\
    mp\x18\r\x20\x01(\x03R\x15best_header_timestamp\x12\x18\n\x07version\x18\
    \x0e\x20\x01(\tR\x07version\x124\n\x15num_inactive_channels\x18\x0f\x20\
    \x01(\rR\x15num_inactive_channels\"G\n\x13ChannelGraphRequest\x120\n\x13\
    include_unannounced\x18\x01\x20\x01(\x08R\x13include_unannounced\"X\n\
    \x0cChannelGraph\x12$\n\x05nodes\x18\x01\x20\x03(\x0b2\x0e.LightningNode\
    R\x05nodes\x12\"\n\x05edges\x18\x02\x20\x03(\x0b2\x0c.ChannelEdgeR\x05ed\
    ges\"\xa3\x01\n\rLightningNode\x12\x20\n\x0blast_update\x18\x01\x20\x01(\
    \rR\x0blast_update\x12\x18\n\x07pub_key\x18\x02\x20\x01(\tR\x07pub_key\
    \x12\x14\n\x05alias\x18\x03\x20\x01(\tR\x05alias\x12*\n\taddresses\x18\
    \x04\x20\x03(\x0b2\x0c.NodeAddressR\taddresses\x12\x14\n\x05color\x18\
    \x05\x20\x01(\tR\x05color\";\n\x0bNodeAddress\x12\x18\n\x07network\x18\
    \x01\x20\x01(\tR\x07network\x12\x12\n\x04addr\x18\x02\x20\x01(\tR\x04add\
    r\"\xaf\x02\n\x0bChannelEdge\x12\x1e\n\nchannel_id\x18\x01\x20\x01(\x04R\
    \nchannel_id\x12\x1e\n\nchan_point\x18\x02\x20\x01(\tR\nchan_point\x12\
    \x20\n\x0blast_update\x18\x03\x20\x01(\rR\x0blast_update\x12\x1c\n\tnode\
    1_pub\x18\x04\x20\x01(\tR\tnode1_pub\x12\x1c\n\tnode2_pub\x18\x05\x20\
    \x01(\tR\tnode2_pub\x12\x1a\n\x08capacity\x18\x06\x20\x01(\x03R\x08capac\
    ity\x122\n\x0cnode1_policy\x18\x07\x20\x01(\x0b2\x0e.RoutingPolicyR\x0cn\
    ode1_policy\x122\n\x0cnode2_policy\x18\x08\x20\x01(\x0b2\x0e.RoutingPoli\
    cyR\x0cnode2_policy\"\xd3\x01\n\rRoutingPolicy\x12(\n\x0ftime_lock_delta\
    \x18\x01\x20\x01(\rR\x0ftime_lock_delta\x12\x1a\n\x08min_htlc\x18\x02\
    \x20\x01(\x03R\x08min_htlc\x12$\n\rfee_base_msat\x18\x03\x20\x01(\x03R\r\
    fee_base_msat\x12:\n\x0efee_rate_milli\x18\x04\x20\x01(\x0b2\r.MilliSato\
    shiR\x13fee_rate_milli_msat\x12\x1a\n\x08disabled\x18\x05\x20\x01(\x08R\
    \x08disabled\"\xb0\x01\n\x12QueryRoutesRequest\x12\x17\n\x07pub_key\x18\
    \x01\x20\x01(\tR\x06pubKey\x12\x10\n\x03amt\x18\x02\x20\x01(\x03R\x03amt\
    \x12\x1d\n\nnum_routes\x18\x03\x20\x01(\x05R\tnumRoutes\x12(\n\x10final_\
    cltv_delta\x18\x04\x20\x01(\x05R\x0efinalCltvDelta\x12&\n\tfee_limit\x18\
    \x05\x20\x01(\x0b2\t.FeeLimitR\x08feeLimit\"+\n\tRouteList\x12\x1e\n\x06\
    routes\x18\x01\x20\x03(\x0b2\x06.RouteR\x06routes2\x9f\x02\n\x0eRoutingS\
    ervice\x12:\n\x0bSignMessage\x12\x13.SignMessageRequest\x1a\x14.SignMess\
    ageResponse\"\0\x12+\n\x0bConnectPeer\x12\x13.ConnectPeerRequest\x1a\x05\
    .Void\"\0\x12\x1f\n\tListPeers\x12\x05.Void\x1a\t.PeerList\"\0\x12\x19\n\
    \x07GetInfo\x12\x05.Void\x1a\x05.Info\"\0\x126\n\rDescribeGraph\x12\x14.\
    ChannelGraphRequest\x1a\r.ChannelGraph\"\0\x120\n\x0bQueryRoutes\x12\x13\
    .QueryRoutesRequest\x1a\n.RouteList\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
